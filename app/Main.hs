{-# LANGUAGE BangPatterns, LambdaCase #-}

module Main where

import           Help
import           Input
import           Fractals
import           Colors
import           Data.Complex
import qualified Graphics.Image                as I
import qualified Graphics.Image.Interface      as I
import           System.IO
import           Data.Word
import           System.Environment
import           System.Directory
import           Text.Printf
import           Data.Time

-- Entry point for program
main :: IO ()
main = do
   args <- getArgs

   if not (length args == 0) &&
      (  head args == "h"
      || head args == "-h"
      || head args == "help"
      || head args == "-help"
      || head args == "?"
      || head args == "-?")
     then do
        putStrLn $ help args
        hFlush stdout
     else do
        let options = processArgs args
        putStrLn $ pPrintOptions options
        hFlush stdout
        fractal args options

   -- TODO add parametric cval animation using hint package?

fractal :: [String] -> Options -> IO ()
fractal args options@(Options fractalType (numRows, numColumns) (cReal :+ cImag)
                              range iterations power aaIn normalization color
                              animation cValue setColor framesIn startingFrame)
   = do
      currentDir <- getCurrentDirectory
      {- Path is generated by finding the current date/time, replacing colons (an invalid character in
       Windows paths) with an alternate Unicode colon, and removing the last 12 digits (which contain
       the fractional part of the seconds and the "UTC" code) -}
      path       <- fmap
         ( ((currentDir ++ "\\Generated Fractals\\") ++)
         . reverse . drop 12 . reverse
         . map (\case ':' -> '\xA789'; x -> x)
         . show
         )
         getCurrentTime
      createDirectoryIfMissing True path
      setCurrentDirectory path
      writeFile ("data.txt") $ (pPrintOptions options) ++ '\n' : "Arguments:       " ++ (unwords args)
      putStr $ "0/" ++ (show frames)
      hFlush stdout
      mapM_
         (\frame -> do
            I.writeImageExact (I.PNG) []
                  (path ++ '\\' : show (frame + startingFrame) ++ ".png") $
                  I.toManifest $ I.toWord8I $ I.makeImageR I.RPS
                                       (numRows, numColumns)
                                       (\point -> colorFunc $ fractalFunction frame point)
            putStr ('\r' : (show $ frame + startingFrame) ++ '/' : (show $ floor frames))
            hFlush stdout
         )
         [0 .. (truncate frames) - 1]
 where
  frames = case animation of NoAnimation -> 1; otherwise -> fromIntegral framesIn
  colorFunc =
     case color of
           Greyscale                    -> colorGrey setColor
           Hue                          -> colorHue setColor
           (Gradient isCircular colors) -> colorGrad setColor isCircular colors
        . fmap
             (case normalization of
                Linear                 -> (normLinear iterations)
                (Sigmoid center power) -> normSigmoid center power
                (Periodic period     ) -> normPeriodic period
                (Sine     period     ) -> normSine period
             )
  aa = case aaIn of AAEnabled  -> True; AADisabled -> False
  animVals = map
     (case animation of
        (Zoom final _) -> ((exp $ (log (final / range)) / (frames - 1)) **)
        otherwise ->
           case animation of
                 NoAnimation        -> \x -> 1
                 (Power      final) -> interpolate power final
                 (Iterations final) -> interpolate (fromIntegral iterations) (fromIntegral final)
                 (Theta      final) -> interpolate (phase cValue) (final * pi / 180)
                 (LinearC    final) -> interpolate (realPart cValue) (realPart final)
              . (if frames /= 1 then (/ (frames - 1)) else id)
     )
     [fromIntegral startingFrame - 1 .. frames - 1]
  altAnimVals = case animation of
     (Zoom _ finalIter) -> map
        ((interpolate (fromIntegral iterations) (fromIntegral finalIter)) . (/ frames)
        . (if frames /= 1 then (/ (frames - 1)) else id)
        )
        [fromIntegral startingFrame - 1 .. frames - 1]
     (LinearC final) -> map
        (interpolate (imagPart cValue) (imagPart final)
        . (if frames /= 1 then (/ (frames - 1)) else id)
        )
        [fromIntegral startingFrame - 1 .. frames - 1]
  fractalFunction :: Int -> (Int, Int) -> Maybe Double
  fractalFunction frame (r, c) = case (fractalType, animation) of
     -- Mandelbrot animation functions
     (Mandelbrot, NoAnimation) ->
        pMandelbrot aa pixelSize iterations power $ pairToComplex (r, c)
     (Mandelbrot, Power _) ->
        pMandelbrot aa pixelSize iterations value $ pairToComplex (r, c)
     (Mandelbrot, Zoom _ _) ->
        pMandelbrot aa (pixelSize * value) (round $ altValue) power $ pairToComplexZ (r, c) value
     (Mandelbrot, Iterations _) ->
        pMandelbrot aa pixelSize (round value) power $ pairToComplex (r, c)
     (Mandelbrot, Theta _) ->
        error "Theta animations can only be generated for Julia fractals"
     (Mandelbrot, LinearC _) ->
        error "Linear C-Value animations can only be generated for Julia fractals"
     -- Julia animation functions
     (Julia, NoAnimation) ->
        pJulia aa pixelSize iterations power cValue $ pairToComplex (r, c)
     (Julia, Power _ ) ->
        pJulia aa pixelSize iterations value cValue $ pairToComplex (r, c)
     (Julia, Zoom _ _) ->
        pJulia aa (pixelSize * value) (round $ altValue) power cValue $ pairToComplexZ (r, c) value
     (Julia, Iterations _) ->
        pJulia aa pixelSize (round value) power cValue $ pairToComplex (r, c)
     (Julia, Theta _) ->
        pJulia aa pixelSize iterations power (mkPolar cMag value) $ pairToComplex (r, c)
     (Julia, LinearC _) ->
        pJulia aa pixelSize iterations power (value :+ altValue) $ pairToComplex (r, c)
   where
    -- The value being animated
    value      = animVals !! frame
    altValue   = altAnimVals !! frame
    -- Other values
    pixelSize = (2 * range) / (fromIntegral $ numColumns - 1)
    cMag      = magnitude cValue
    cPhase    = phase cValue
    halfV     = 0.5 * fromIntegral numRows
    halfH     = 0.5 * fromIntegral numColumns
    -- Function to get a complex point from a pixel coordinate pair
    pairToComplex (r, c) =
       (cReal - range + fromIntegral c * pixelSize)
          :+ (cImag + (pixelSize * (fromIntegral (numRows - 1) / 2)) - fromIntegral r * pixelSize)    
    -- Same as above but for zoom animations
    pairToComplexZ (r, c) zoomFactor =
       ((fromIntegral c - halfH) * pixelSize * zoomFactor + cReal)
          :+ ((fromIntegral r - halfV) * pixelSize * zoomFactor - cImag)

-- Helper function for interpolating from the start to the end of an animation's value range
interpolate :: Double -> Double -> Double -> Double
interpolate i f p = (i +) $ (* p) $ (f - i)
